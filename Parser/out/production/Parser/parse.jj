PARSER_BEGIN(Parser)

import AST.*;

public class Parser {
    public static void main(String[] args) {
        try {
            Parser parser = new Parser(new java.io.FileReader("code.txt"));
	        Node prog = parser.prog();

            System.out.println("Syntax is good");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax error: " + e.getMessage());
        }
    }
}

PARSER_END(Parser)

SKIP:
{ " "
| "\t"
| "\n"
| "\r"
| <COMMENT : "/*" (~["/"] | "/" ~["/"])* "*/" >
}

TOKEN : /* Numbers */
{ <INTDCL: "int">
| <INT: ( < DIGIT > )>
| <FLOATDCL: "float">
| <FLOAT: ( < DIGIT > ) (".") ( < DIGIT > )>
| <#DIGIT: ( "0" | ["1"-"9"] ( ["0"-"9"] )* ) >
| <PLUS: "+">
| <MINUS: "-">
}

TOKEN: /* LOGIC */
{ <IF: "if">
| <ELSE: "else">
| <AND: "&&">
| <OR: "||">
| <NOT: "!">
| <EQ: "==">
| <NE: "!=">
| <LT: "<">
| <LE: "<=">
| <GT: ">">
| <GE: ">=">
| <BOOLDCL: "boolean">
| <TRUE: "true" >
| <FALSE: "false" >
}

TOKEN : /* Operators and constructs */
{ <ASSIGN: "=">
| <LPAREN: "(">
| <RPAREN: ")">
| <LBRACE: "{">
| <RBRACE: "}">
| <END_OF_LINE: ";">
| <END_OF_FILE: "BYE">
| <PRINT: "print">
}

TOKEN : /* ID */
{ <ID: (["a"-"z", "A"-"Z", "_"]) (["a"-"z", "A"-"Z", "_", "0"-"9"])*> }


Node prog() :
{
 Prog prog = new Prog();
 Node dcl;
 Node stmt;
 }
{( dcl = dcl() { prog.addChild(dcl); } | stmt = stmt() { prog.addChild(stmt); } )* < END_OF_FILE > < END_OF_LINE >
{
    return prog;
}
}

Node dcl() :
{
 boolean hasExpr = false;
 Node expr = null;
 Token t;
 }
{ < FLOATDCL > t = < ID > ( < ASSIGN > expr = expr() { hasExpr = true; } )? < END_OF_LINE >
{
    if (hasExpr) {
        FloatDcl floatDcl = new FloatDcl(t.image);
        return new Assigning(floatDcl, expr);
    } else {
        return new FloatDcl(t.image);
    }
 }
| < INTDCL > t = < ID > ( < ASSIGN > expr = expr() { hasExpr = true; } )? < END_OF_LINE >
{
    if (hasExpr) {
        IntDcl intDcl = new IntDcl(t.image);
        return new Assigning(intDcl, expr);
    } else {
        return new IntDcl(t.image);
    }
}
| < BOOLDCL > t = < ID > ( < ASSIGN > expr = expr() { hasExpr = true; } )? < END_OF_LINE >
{
    if (hasExpr) {
        BoolDcl boolDcl = new BoolDcl(t.image);
        return new Assigning(boolDcl, expr);
    } else {
        return new BoolDcl(t.image);
    }
}
}

Node stmt() :
{
    boolean withELse = false;
    Node expr;
    Token t;
}
{ t = < ID > < ASSIGN > expr = expr() < END_OF_LINE >
{
    Id id = new Id(t.image);
    return new Assigning(id, expr);
}
| < PRINT > < LPAREN > t = < ID > < RPAREN > < END_OF_LINE >
{
    return new Print(t.image);
}
}

Node expr2() :
{
    boolean hasExpr = false;
    Node expr = null;
    Node val;
    Token op = null;
 }
{ val = val() ( ( op = < PLUS > | op = < MINUS > ) expr = expr() { hasExpr = true; } )?
{
    if (hasExpr) {
        return new Computing(op.image, val, expr);
    } else {
        return val;
    }
}
}

Node expr() :
{
    boolean hasExpr = false;
    Node term;
    Node expr = null;
    Token op = null;
 }
{ term = term() (( op = <AND> | op = <OR> ) expr = expr() { hasExpr = true; } )?
{
    if (hasExpr) {
        return new BinOperator(op.image, term, expr);
    } else {
        return term;
    }
}
}

Node term() :
{
    boolean hasTerm = false;
     Node addTerm;
     Node term = null;
     Token op = null;
 }
{addTerm = addTerm() (( op = <LT> | op = <GT> | op = <GE> | op = <LE> )term = term() { hasTerm = true; })?
{
    if (hasTerm) {
        return new BinOperator(op.image, addTerm, term);
    } else {
        return addTerm;
    }
}
}

Node addTerm() :
{
    boolean hasAddTerm = false;
    Node factor;
    Node addTerm = null;
    Token op = null;
 }
{ factor = factor() ((op = <PLUS> | op = <MINUS> ) addTerm = addTerm() { hasAddTerm = true; })?
{
    if (hasAddTerm) {
        return new Computing(op.image, factor, addTerm);
    } else {
        return factor;
    }
}
}

Node factor() :
{
    Node val;
    Node expr;
 }
{ <LPAREN> expr = expr() <RPAREN>
{
    return expr;
}
| val = val()
{
    return val;
}
}

Node val() :
{
    Token t;
 }
{ t = < INT >
{
    return new IntNum(t.image);
}
| t = < FLOAT >
{
    return new FloatNum(t.image);
}
| t = < ID >
{
    return new Id(t.image);
}
| (t = < TRUE > | t = < FALSE >)
{
    return new Bool(t.image);
}
}

