PARSER_BEGIN(Parser)

public class Parser {
   public static void main(String[] args) {
       try {
           Parser parser = new Parser(new java.io.FileReader("code.txt"));
           parser.prog();

           SimpleNode root = (SimpleNode) parser.jjtree.rootNode();
           root.dump("");

           System.out.println("Syntax is good");
       } catch (Throwable e) {
           // Catching Throwable is ugly but JavaCC throws Error objects!
           System.out.println("Syntax error: " + e.getMessage());
       }
   }
}

PARSER_END(Parser)

SKIP:
{ " "
| "\t"
| "\n"
| "\r"
| <COMMENT : "/*" (~["/"] | "/" ~["/"])* "*/" >
}

TOKEN : /* Numbers */
{ <INTDCL: "int">
| <INT: ( < DIGIT > )>
| <FLOATDCL: "float">
| <FLOAT: ( < DIGIT > ) (".") ( < DIGIT > )>
| <#DIGIT: ( "0" | ["1"-"9"] ( ["0"-"9"] )* ) >
| <PLUS: "+">
| <MINUS: "-">
}

TOKEN: /* LOGIC */
{ <IF: "if">
| <ELSE: "else">
| <LBRACE: "{">
| <RBRACE: "}">
| <AND: "&&">
| <OR: "||">
| <NOT: "!">
| <EQ: "==">
| <NE: "!=">
| <LT: "<">
| <LE: "<=">
| <GT: ">">
| <GE: ">=">
| <BOOLDCL: "boolean">
| <TRUE: "true" >
| <FALSE: "false" >
}

TOKEN : /* Operators and constructs */
{ <ASSIGN: "=">
| <LPAREN: "(">
| <RPAREN: ")">
/*
| <LCURL: "{">
| <RCURL: "}">
*/
| <END_OF_LINE: ";">
| <END_OF_FILE: "BYE">
| <PRINT: "print">
}


TOKEN : /* ID */
{ <ID: (["a"-"z", "A"-"Z", "_"]) (["a"-"z", "A"-"Z", "_", "0"-"9"])*> }


void prog() :
{}
{ ( ( dcl() | stmt() ) )* end_of_file() }

void dcl() : /* val only in expr */
{}
{
( < FLOATDCL > | < INTDCL > | < BOOLDCL > ) < ID > ( < ASSIGN > val() ( expr() )? )? < END_OF_LINE >
}

void stmt() : /* val only in expr */
{}
{ < ID > < ASSIGN > val() ( expr() )? < END_OF_LINE >
| < PRINT > < LPAREN > < ID > < RPAREN > < END_OF_LINE >
| ifStmt() /* < END_OF_LINE > */
}

void val() :
{
    // Check for consecutive MINUS tokens
    Token nextToken = getToken(1);
    if (token.image.equals("-") && nextToken.image.equals("-")) {
        throw new ParseException("Encountered more than one '-' at line " + token.beginLine + ", column " + token.beginColumn + '.');
    }
}
{ (< MINUS >)? ( < INT > | < FLOAT > )
| < TRUE >
| < FALSE >
| < LPAREN > ( < MINUS > )? ( < INT > | < FLOAT > ) < RPAREN >
| < ID >
}


void expr() : /* val only in expr */
{}
{
( < PLUS > | < MINUS > | < LT > | < GT > | < GE > | < LE > ) val() ( expr() )?
}


void ifStmt() :
{}
{
    <IF> <LPAREN> condition() <RPAREN> <LBRACE> stmt() <RBRACE> (<ELSE> <LBRACE> stmt() <RBRACE>)?
}

void condition() :
{}
{
    comparison() ( conditionTail() )?
}

void conditionTail() :
{}
{
    conditionTailHelper()
}

void conditionTailHelper() :
{}
{
    < AND > comparison() ( conditionTail() )?
    | < OR > comparison() ( conditionTail() )?
}

void comparison() :
{}
{
    term() ( comparisonTail() )?
}

void comparisonTail() :
{}
{
    comparisonTailHelper()
}

void comparisonTailHelper() :
{}
{
    (< EQ > | < NE > | < LT > | < LE > | < GT > | < GE >) term() ( comparisonTail() )?
}

void term() :
{}
{
    factor() ( termTail() )?
}

void termTail() :
{}
{
    termTailHelper()
}

void termTailHelper() :
{}
{
    (< PLUS > | < MINUS >) factor() ( termTail() )?
}

void factor() :
{}
{ < INT >
| < FLOAT >
| < LPAREN > term() < RPAREN >
| < ID >
| < TRUE >
| < FALSE >
}

void end_of_file() :
{}
{ < END_OF_FILE > < END_OF_LINE > }

