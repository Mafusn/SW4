PARSER_BEGIN(Parser)

import AST.*;

public class Parser {
   public static void main(String[] args) {
       try {
           Visitor prettyPrint = new PrettyPrint();

           Parser parser = new Parser(new java.io.FileReader("code.txt"));
           Node root = parser.prog();
           root.accept(prettyPrint);

           System.out.println("Syntax is good");
       } catch (Throwable e) {
           // Catching Throwable is ugly but JavaCC throws Error objects!
           System.out.println("Syntax error: " + e.getMessage());
       }
   }
}

PARSER_END(Parser)

SKIP:
{ " "
| "\t"
| "\n"
| "\r"
| <COMMENT : "/*" (~["/"] | "/" ~["/"])* "*/" >
}

TOKEN : /* Numbers */
{ <INTDCL: "int">
| <INT: ( < MINUS > )? ( < DIGIT > )>
| <FLOATDCL: "float">
| <FLOAT: ( < MINUS > )? ( < DIGIT > ) (".") ( < DIGIT > )>
| <#DIGIT: ( "0" | ["1"-"9"] ( ["0"-"9"] )* ) >
| <PLUS: "+">
| <MINUS: "-">
}

TOKEN: /* LOGIC */
{ <IF: "if">
| <ELSE: "else">
| <AND: "&&">
| <OR: "||">
| <NOT: "!">
| <EQ: "==">
| <NE: "!=">
| <LT: "<">
| <LE: "<=">
| <GT: ">">
| <GE: ">=">
| <BOOLDCL: "boolean">
| <TRUE: "true" >
| <FALSE: "false" >
}

TOKEN : /* Operators and constructs */
{ <ASSIGN: "=">
| <LPAREN: "(">
| <RPAREN: ")">
| <LBRACE: "{">
| <RBRACE: "}">
| <END_OF_LINE: ";">
| <END_OF_FILE: "BYE">
| <PRINT: "print">
}

TOKEN : /* ID */
{ <ID: (["a"-"z", "A"-"Z", "_"]) (["a"-"z", "A"-"Z", "_", "0"-"9"])*> }

Node prog() :
{
    Node prog = new ProgNode();
    Node dcl;
    Node stmt;
}
{ ( ( dcl = dcl() { prog.addChild(dcl); } | stmt = stmt() { prog.addChild(stmt); } ) )* < END_OF_FILE > < END_OF_LINE >
{
    return prog;
}
}

Node dcl() :
{
    boolean dclWithVal = false;
    boolean dclWithValAndExpr = false;
    Token t;
    Node val = null;
    Node expr = null;
}
{ < INTDCL > t = < ID > ( < ASSIGN > val = val() (( expr = expr() { dclWithValAndExpr = true; } ))? { dclWithVal = true; } )? < END_OF_LINE >
{
    IntDclNode intDclNode = new IntDclNode(t.image);
    if (dclWithValAndExpr) {return new AssignNode(intDclNode, val, expr);}
    if (dclWithVal) {return new AssignNode(intDclNode, val);}
    return intDclNode;
}
| < FLOATDCL > t = < ID > ( < ASSIGN > val = val() (( expr = expr() { dclWithValAndExpr = true; } ))? { dclWithVal = true; } )? < END_OF_LINE >
{
    FloatDclNode floatDclNode = new FloatDclNode(t.image);
    if (dclWithValAndExpr) {return new AssignNode(floatDclNode, val, expr);}
    if (dclWithVal) {return new AssignNode(floatDclNode, val);}
    return floatDclNode;
}
| < BOOLDCL > t = < ID > ( < ASSIGN > val = val() (( expr = expr() { dclWithValAndExpr = true; } ))? { dclWithVal = true; } )? < END_OF_LINE >
{
    BoolDclNode boolDclNode = new BoolDclNode(t.image);
    if (dclWithValAndExpr) {return new AssignNode(boolDclNode, val, expr);}
    if (dclWithVal) {return new AssignNode(boolDclNode, val);}
    return boolDclNode;
}
}

Node stmt() :
{
    boolean withExpr = false;
    boolean withElse = false;
    Node val = null;
    Node expr = null;
    Node condition = null;
    Node elseNode = null;
    Node ifBlock = null;
    Node elseBlock = null;
    Token t;
}
{ t = < ID > < ASSIGN > val = val() ( expr = expr() { withExpr = true; } )? < END_OF_LINE >
{
    IdNode idNode = new IdNode(t.image);
    if (withExpr) { return new AssignNode(idNode, val, expr); }
    else { return new AssignNode(idNode, val); }
}
| < PRINT > < LPAREN > t = < ID > < RPAREN > < END_OF_LINE >
{
    return new PrintNode(t.image);
}
| < IF > < LPAREN > condition = condition() < RPAREN > < LBRACE > ifBlock = block() < RBRACE >
  ( < ELSE > < LBRACE > elseBlock = block() < RBRACE > { withElse = true; } )?
{
    if (withElse) { return new IfElseStmtNode(condition, ifBlock, elseBlock); }
    return new IfStmtNode(condition, ifBlock);
}
}

Node block() :
{
    BlockNode blockNode = new BlockNode();
    Node dcl = null;
    Node stmt = null;
}
{
    ( dcl = dcl() { blockNode.addChild(dcl); } | stmt = stmt() { blockNode.addChild(stmt); } )*
{
    return blockNode;
}
}

Node val() :
{
    boolean withNot = false;
    Node val = null;
    Node expr = null;
    Token t;
    // Check for consecutive MINUS tokens
    Token nextToken = getToken(1);
    if (token.image.equals("-") && nextToken.image.equals("-")) {
        throw new ParseException("Encountered more than one '-' at line " + token.beginLine + ", column " + token.beginColumn + '.');
    }
}
{ t = < INT >
{
    return new IntNode(t.image);
}
| t = < FLOAT >
{
    return new FloatNode(t.image);
}
| t = < TRUE >
{
    return new TrueNode(t.image);
}
| t = < FALSE >
{
    return new FalseNode(t.image);
}
| t = < ID >
{
    return new IdNode(t.image);
}
| < NOT > val = val()
{
    return new NOTNode(val, expr);
}
| < LPAREN > val() ( expr() )? < RPAREN >

}

Node expr() :
{
    Node val = null;
    Node expr = null;
}
{ < PLUS > val = val() ( expr = expr() )?
{
    return new PlusNode(val, expr);
}
| < MINUS > val = val() ( expr = expr() )?
{
    return new MinusNode(val, expr);
}
| < LT > val = val() ( expr = expr() )?
{
    return new LTNode(val, expr);
}
| < GT > val = val() ( expr = expr() )?
{
    return new GTNode(val, expr);
}
| < LE > val = val() ( expr = expr() )?
{
    return new LENode(val, expr);
}
}

Node condition() :
{
    Node comparison = null;
    Node conditionTail = null;
    Node val;
}
{ val = val() ( conditionTail = conditionTail() )?
{
    return new ConditionNode(val, conditionTail);
}
}

Node conditionTail() :
{
    Node operator = null;
    Node conditionTail = null;
    Token t;
    Node val;
}
{ < MINUS > val = val() ( conditionTail = conditionTail() )?
{
    return new MinusNode(val, conditionTail);
}
| < PLUS > val = val() ( conditionTail = conditionTail() )?
{
    return new PlusNode(val, conditionTail);
}
| < EQ > val = val() ( conditionTail = conditionTail() )?
{
    return new EQNode(val, conditionTail);
}
| < NE > val = val() ( conditionTail = conditionTail() )?
{
    return new NENode(val, conditionTail);
}
| < LT > val = val() ( conditionTail = conditionTail() )?
{
    return new LTNode(val, conditionTail);
}
| < LE > val = val() ( conditionTail = conditionTail() )?
{
    return new LENode(val, conditionTail);
}
| < GT > val = val() ( conditionTail = conditionTail() )?
{
    return new GTNode(val, conditionTail);
}
| < GE > val = val() ( conditionTail = conditionTail() )?
{
    return new GENode(val, conditionTail);
}
| < AND > val = val() ( conditionTail = conditionTail() )?
{
    return new ANDNode(val, conditionTail);
}
| < OR > val = val() ( conditionTail = conditionTail() )?
{
    return new ORNode(val, conditionTail);
}
| ( < NOT > )? < LPAREN > val = val() ( conditionTail = conditionTail() )? < RPAREN >
{
    return new NOTNode(val, conditionTail);
}
}
