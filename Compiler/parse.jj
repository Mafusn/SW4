options {
  STATIC = false;
}

PARSER_BEGIN(Compiler)

import AST.*;
import AST.CodeGeneration.CodeGenerator;
import AST.Nodes.*;
import AST.SymbolTableFilling.SymbolTableFilling;

public class Compiler {
    public static void main(String[] args) {
        try {
            Compiler compiler = new Compiler(new java.io.FileReader("code.txt"));
            Node prog = compiler.prog();

            PrettyPrint prettyPrint = new PrettyPrint();
            SymbolTableFilling symbolTableFilling = new SymbolTableFilling();
            TypeChecking typeChecking = new TypeChecking(symbolTableFilling);
            CodeGenerator codeGenerator = new CodeGenerator(symbolTableFilling);

            prog.accept(prettyPrint);
            System.out.println(prettyPrint.getResult());
            System.out.println();
            System.out.print("Syntax is good");
            prog.accept(symbolTableFilling);
            System.out.println("Symbol table is good");
            prog.accept(typeChecking);
            System.out.println("Type check is good");
            prog.accept(codeGenerator);
            System.out.println("Code generator is good");

            codeGenerator.generateCode();

        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax error: " + e.getMessage());
        }
    }
}

PARSER_END(Compiler)

SKIP: /* SKIP */
{ " "
| "\t"
| "\n"
| "\r"
| <COMMENT : "/*" (~["/"] | "/" ~["/"])* "*/" >
}

TOKEN : /* NUMBERS AND ARITHMETIC OPERATIONS */
{ <INTDCL: "int">
| <INT: ( < DIGIT > )>
| <FLOATDCL: "float">
| <FLOAT: ( < DIGIT > ) (".") ( < DIGIT > )+ >
| <#DIGIT: ( "0" | ["1"-"9"] ( ["0"-"9"] )* ) >
| <PLUS: "+">
| <MINUS: "-">
| <MULTIPLY: "*">
}

TOKEN: /* LOGIC */
{ <IF: "if">
| <ELSE: "else">
| <AND: "&&">
| <OR: "||">
| <NOT: "!">
| <EQ: "==">
| <NE: "!=">
| <LT: "<">
| <LE: "<=">
| <GT: ">">
| <GE: ">=">
| <BOOLDCL: "boolean">
| <TRUE: "true" >
| <FALSE: "false" >
}

TOKEN : /* ASSIGNMENT OPERATION AND BASIC CONTROL STRUCTURE */
{ <ASSIGN: "=">
| <LPAREN: "(">
| <RPAREN: ")">
| <LBRACE: "{">
| <RBRACE: "}">
| <END_OF_LINE: ";">
| <END_OF_FILE: "BYE">
| <ADDRESS: "&">
}

TOKEN : /* ID */
{ <ID: (["a"-"z", "A"-"Z", "_"]) (["a"-"z", "A"-"Z", "_", "0"-"9"])*> }


Node prog() :
{
 Prog prog = new Prog();
 Node stmt = null;
 }
{( stmt = stmt() { prog.addChild(stmt); } )* < END_OF_FILE > < END_OF_LINE >
{
    return prog;
}
}

Node dcl() :
{
 boolean hasExpr = false;
 boolean isPointer = false;
 Node expr = null;
 Token t;
 }
{ < FLOATDCL > t = < ID > ( < ASSIGN > expr = expr() { hasExpr = true; } )?
{
    /*if (hasExpr && isPointer) {
       return null;
       } else */

   if (hasExpr) {
       FloatDcl floatDcl = new FloatDcl(t.image);
       return new AssignmentOp(t.image, floatDcl, expr);
   } else {
       return new FloatDcl(t.image);
   }
}
| < INTDCL > t = < ID > ( < ASSIGN > expr = expr() { hasExpr = true; } )?
{
     /*if (hasExpr && isPointer) {
        return null;
        } else */
    if (hasExpr) {
        IntDcl intDcl = new IntDcl(t.image);
        return new AssignmentOp(t.image, intDcl, expr);
    } else {
        return new IntDcl(t.image);
    }
}
| < BOOLDCL > t = < ID > ( < ASSIGN > expr = expr() { hasExpr = true; } )?
{
    /*if (hasExpr && isPointer) {
    return null;
    ( < MULTIPLY > { isPointer = true; } )?
    } else */
    if (hasExpr) {
        BoolDcl boolDcl = new BoolDcl(t.image);
        return new AssignmentOp(t.image, boolDcl, expr);
    } else {
        return new BoolDcl(t.image);
    }
}
}

Node stmt() :
{
    boolean isPointer = false;
    Node ifStmt;
    Node dcl;
    Node expr;
    Token t;
}
{ t = < ID > < ASSIGN > expr = expr() < END_OF_LINE >
{
/*
( < MULTIPLY > { isPointer = true; } )?
 */
    Id id = new Id(t.image);
    return new AssignmentOp(t.image, id, expr);
}
| ifStmt = ifStmt()
{
return ifStmt;
}
| dcl = dcl() < END_OF_LINE >
{
    return dcl;
}
}
Node ifStmt() :
{
 Node expr;
 Node ifBlock;
 Node elseBlock = null;
 boolean withElse = false;
}
{
< IF > < LPAREN > expr = expr() < RPAREN > < LBRACE > ifBlock = block() < RBRACE > ( < ELSE > < LBRACE > elseBlock = block() < RBRACE > { withElse = true; })?
{
    if (withElse) {
        return new IfElseStmt(expr, ifBlock, elseBlock);
    } else {
        return new IfStmt(expr, ifBlock);
    }
}
}

Node block() :
{
   Block block = new Block();
   Node stmt = null;
}
{
( stmt = stmt() { block.addChild(stmt); } )*
{
    return block;
}
}

Node expr() :
{
 Node expr;
 Node orOp = null;
}
{ expr = orOp()
{
    return orOp;
}
}

Node orOp() :
{
    boolean hasExpr = false;
    Node andOp;
    Node expr = null;
    Token op = null;
}
{ andOp = andOp() (( op = <OR> ) expr = expr() { hasExpr = true; } )?
{
    if (hasExpr) {
        return new ComparisonOp(op.image, andOp, expr);
    } else {
        return andOp;
    }
}
}

Node andOp() :
{
    boolean hasAndOp = false;
    Node equalityOp;
    Node andOp = null;
    Token op = null;
}
{equalityOp = equalityOp() (( op = <AND>) andOp = andOp() {hasAndOp = true;})?
{
    if (hasAndOp) {
        return new ComparisonOp(op.image, equalityOp, andOp);
    } else {
        return equalityOp;
    }
}
}

Node equalityOp() :
{
    boolean hasEqualityOp = false;
    Node comparisonOp;
    Node equalityOp = null;
    Token op = null;
}
{comparisonOp = comparisonOp() (( op = <EQ> | op = <NE>) equalityOp = equalityOp() {hasEqualityOp = true;})?
{
    if (hasEqualityOp) {
        return new ComparisonOp(op.image, comparisonOp, equalityOp);
    } else {
        return comparisonOp;
    }
}
}
Node comparisonOp() :
{
    boolean hasComparisonOp = false;
     Node arithmeticOp;
     Node comparisonOp = null;
     Token op = null;
 }
{arithmeticOp = arithmeticOp() (( op = <LT> | op = <GT> | op = <GE> | op = <LE> )comparisonOp = comparisonOp() { hasComparisonOp = true; })?
{
    if (hasComparisonOp) {
        return new ComparisonOp(op.image, arithmeticOp, comparisonOp);
    } else {
        return arithmeticOp;
    }
}
}

Node arithmeticOp() :
{
    boolean hasArithmeticOp = false;
    Node negationOp;
    Node arithmeticOp = null;
    Token op = null;
 }
{ negationOp = negationOp() ((op = <PLUS> | op = <MINUS> ) arithmeticOp = arithmeticOp() { hasArithmeticOp = true; })?
{
    if (hasArithmeticOp) {
        return new ArithmeticOp(op.image, negationOp, arithmeticOp);
    } else {
        return negationOp;
    }
}
}
Node negationOp() :
{
    Node factor;
    boolean hasNegationOp = false;
}
{
 ( <NOT> { hasNegationOp = true; })? factor = factor()
{
    if (hasNegationOp) {
        return new NegationOp(factor);
    } else {
        return factor;
    }
}
}

Node factor() :
{
    Node val;
    Node expr;
 }
{ <LPAREN> expr = expr() <RPAREN>
{
    return expr;
}
| val = val()
{
    return val;
}
}

Node val() :
{
    Token t;
 }
{ t = < INT >
{
    return new IntNum(t.image);
}
| t = < FLOAT >
{
    return new FloatNum(t.image);
}
| t = < ID >
{
    return new Id(t.image);
}
| (t = < TRUE > | t = < FALSE >)
{
    return new Bool(t.image);
}
/*
| < ADDRESS > t = < ID >
{
    return new Bool(t.image);
}

 */
}

