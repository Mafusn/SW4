/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. .\parse.jj.jj */
/*@egen*/PARSER_BEGIN(Parser)

public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTParserState jjtree = new JJTParserState();

/*@egen*/
   public static void main(String[] args) {
       try {
           Parser parser = new Parser(new java.io.FileReader("code.txt"));
          parser.prog();

           SimpleNode root = (SimpleNode) parser.jjtree.rootNode();
           root.dump("");

           System.out.println("Syntax is good");
       } catch (Throwable e) {
           // Catching Throwable is ugly but JavaCC throws Error objects!
           System.out.println("Syntax error: " + e.getMessage());
       }
   }
}

PARSER_END(Parser)

SKIP:
{ " "
| "\t"
| "\n"
| "\r"
}

TOKEN : /* Numbers */
{ <INTDCL: "int">
 | <INT: (<MINUS>)? (<DIGIT>)>
 | <FLOATDCL: "float">
 | <FLOAT: (<MINUS>)? (<DIGIT>)+ (".") (<DIGIT>)+>
 | <#DIGIT: ("0" | ["1"-"9"](["0"-"9"])*)>
 | <PLUS: "+">
 | <MINUS: "-">
}

TOKEN: /* LOGIC */
{
   <IF: "if">
 | <ELSE: "else">
 | <ELSEIF: "elif">
 | <OR: "||">
 | <AND: "&&">
}

TOKEN : /* Operators and constructs */
{ <TRUE: "true" >
 | <FALSE: "false" >
 | <ASSIGN: "=">
 | <LPAREN: "(">
 | <RPAREN: ")">
 | <LCURL: "{">
 | <RCURL: "}">
 | <COMMENT : "/" (~["/"] | "/" ~["/"])* "*/" >
 | <EOL: ";">
 | <END_OF_FILE: "BYE">
 | <PRINT: "print">
}


TOKEN : /* ID */
{ <ID: (["a"-"z", "A"-"Z", "_", "0"-"9"])> }


void prog() :
{/*@bgen(jjtree) prog */
  SimpleNode jjtn000 = new SimpleNode(JJTPROG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) prog */
 try {
/*@egen*/(dcl())+ (stmt())* end_of_file() <EOL>/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/}

void dcl() :
{/*@bgen(jjtree) dcl */
  SimpleNode jjtn000 = new SimpleNode(JJTDCL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) dcl */
  try {
/*@egen*/ < FLOATDCL > <ID > <EOL>
| < INTDCL > <ID > <EOL>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

void stmt() :
{/*@bgen(jjtree) stmt */
  SimpleNode jjtn000 = new SimpleNode(JJTSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) stmt */
  try {
/*@egen*/ < ID ><ASSIGN > val() (expr())? <EOL>
| < PRINT > "(" <ID > ")" <EOL>
| <IF> <LPAREN> ifexpr() <RPAREN> <LCURL> stmt() <RCURL> ( <ELSEIF> <LPAREN> ifexpr() <RPAREN> <LCURL> stmt() <RCURL> )* ( <ELSE> <LCURL> stmt() <RCURL> )? <EOL>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

void val() :
{/*@bgen(jjtree) val */
  SimpleNode jjtn000 = new SimpleNode(JJTVAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) val */
  try {
/*@egen*/ <INT>
| <FLOAT>
| <ID>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ }

void ifexpr():
{/*@bgen(jjtree) ifexpr */
  SimpleNode jjtn000 = new SimpleNode(JJTIFEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ifexpr */
  try {
/*@egen*/ <ID> "=" val() (ifexpr())?
| <OR> ifexpr()
| <AND> ifexpr()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ }


void expr() :
{/*@bgen(jjtree) expr */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) expr */
  try {
/*@egen*/ <PLUS> val() (expr())?
| <MINUS> val() (expr())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

void end_of_file() :
{/*@bgen(jjtree) end_of_file */
  SimpleNode jjtn000 = new SimpleNode(JJTEND_OF_FILE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) end_of_file */
 try {
/*@egen*/
 <END_OF_FILE>/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}
